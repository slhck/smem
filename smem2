#!/usr/bin/env python3
#
# smem2 - a tool for meaningful memory reporting
#
# Copyright 2008-2009 Matt Mackall <mpm@selenic.com>, 2021 GdH <github.com/G-dH/smem2>, 2024 slhck <github.com/slhck/smem2>
#
# This software may be used and distributed according to the terms of
# the GNU General Public License version 2 or later, incorporated
# herein by reference.
# You can find the full license text in the file COPYING.

# mypy: check-untyped-defs,allow-untyped-globals

from __future__ import annotations

import argparse
import errno
import json
import os
import pwd
import re
import sys
from typing import Callable

__VERSION__ = "2.1.0"

# TODO Remove the necessity of globals, this is a temporary workaround until functions have been updated
IGNORE_AUTOSIZE: set = set()
OPTIONS: argparse.Namespace
PROC: ProcessData
ROLLUP: bool
OWNPID: int
SWAPPSS: bool
PSSDETAIL: bool
RSSDETAIL: bool


class UIDCache(object):
    """Class for a simple ID Cache"""

    def __init__(self):
        self._cache = {}

    def __call__(self, uid):
        """Return if the entry is in cache, else populate the cache"""
        return self._cache.setdefault(uid, self._getpwuid(uid))

    @staticmethod
    def _getpwuid(uid):
        """Return the password database entry for the UID otherwise store just the UID"""
        try:
            return pwd.getpwuid(uid)[0]
        except KeyError:
            return str(uid)


class Proc(object):
    """Helper class to handle /proc/ filesystem data"""

    def __init__(self):
        pass

    @staticmethod
    def listdir():
        return os.listdir("/proc")

    @staticmethod
    def read(filename):
        """Return the file as a string"""
        if not os.path.exists("/proc/" + filename):
            raise RuntimeError(
                f"File /proc/{filename} does not exist, are you sure you are running on a Linux system?"
            )
        return open("/proc/" + filename).read()

    def readlines(self, filename):
        """Return the file as an list of lines"""
        return self.read(filename).splitlines(True)

    def version(self):
        """Return Linux version data"""
        return self.readlines("version")[0]


class MemData(Proc):
    """Class accessing and storing /proc/meminfo data"""

    def __init__(self):
        self._memdata = {}

        regex = re.compile("(?P<name>\\S+):\\s+(?P<amount>\\d+) kB")
        for line in self.readlines("meminfo"):
            match = regex.match(line)
            if match:
                self._memdata[match.group("name").lower()] = int(match.group("amount"))

    def __call__(self, entry):
        """Return the entry when the object is called"""
        return self._memdata[entry]


class ProcessData(Proc):
    """Helper class to handle /proc/<pid> filesystem data"""

    def __init__(self):
        self._uidcache = UIDCache()

    def _iskernel(self, pid):
        """Check if it's a kernel pid"""
        return self.pidcmd(pid) == ""

    @staticmethod
    def _stat(pid):
        """Stat result for the pid"""
        return os.stat("/proc/" + pid)

    def pids(self):
        """Get a list of PID's"""
        global OPTIONS
        global OWNPID
        return [
            int(e)
            for e in self.listdir()
            if e.isdigit()
            and not self._iskernel(e)
            and ((OPTIONS.pid and OPTIONS.pid == int(e)) or not OPTIONS.pid)
            and not ((int(e) == OWNPID) and OPTIONS.processfilter)
        ]
        # exclude own process when processfilter

    def mapdata(self, pid):
        """Return PID smaps data"""
        global ROLLUP
        if ROLLUP:
            try:
                return self.readlines(
                    "%s/smaps_rollup" % pid
                )  # smaps_rollup new from kernel 4.14, at least 7x faster for non maping listing
            except:
                pass
        return self.readlines("%s/smaps" % pid)

    def pidcmd(self, pid):
        """Return PID cmdline data"""
        try:
            c = self.read("%s/cmdline" % pid)[:-1]
            c = c.replace("\0", " ")
            if OPTIONS.basename and not c == "":
                c = os.path.basename(c.split()[0])
            return c
        except:
            return "?"

    def piduser(self, pid):
        """Return PID user data"""
        try:
            return self._stat("%d" % pid).st_uid
        except:
            return -1

    def username(self, uid):
        """Return username from UID cache"""
        return "?" if uid == -1 else self._uidcache(uid)

    def pidusername(self, pid):
        """Return PID username"""
        return self.username(self.piduser(pid))

    def pidtostr(self, pid):
        return str(pid)

    def pidname(self, pid):
        """Return PID comm data"""
        try:
            return self.read("%s/comm" % pid)[:-1]
        except:
            return "?"


def totalmem():
    if OPTIONS.realmem:
        return fromunits(OPTIONS.realmem) / 1024
    else:
        if OPTIONS.system or OPTIONS.sysdetail:
            try:
                # only for systems running directly on HW
                ram = (
                    os.popen(
                        "dmidecode --type memory 2> /dev/null|awk '/Size: [0-9]+ MB/{sum+=$2};END{print sum}'",
                    )
                    .read()
                    .strip()
                )
                if ram.isdigit():
                    return fromunits(str(int(ram)) + "M") / 1024
            except:
                pass

        return MemData()("memtotal")


def pidmaps(pid, nomaps=False):
    maps: dict = {}
    start = None
    status = None
    global ROLLUP
    global PSSDETAIL
    global RSSDETAIL
    global PROC
    if ROLLUP or PSSDETAIL or RSSDETAIL:
        status = PROC.readlines("%s/status" % pid)

    for l in PROC.mapdata(pid):
        f = l.split()
        if f[-1] == "kB":
            maps[start][f[0][:-1].lower()] = int(f[1])
        elif "-" in f[0] and ":" not in f[0]:  # looks like a mapping range
            start, end = f[0].split("-")
            start = int(start, 16)
            name = "<anonymous>"
            if len(f) > 5:
                name = f[5]
                if OPTIONS.basename:
                    name = os.path.basename(name)
            maps[start] = dict(
                end=int(end, 16),
                mode=f[1],
                offset=int(f[2], 16),
                device=f[3],
                inode=f[4],
                name=name,
            )
    if status:  # no VSS info in smaps_rollup
        for l in status:
            l = l.split()
            if ROLLUP and l[0] == "VmSize:":
                maps[start]["size"] = int(l[1])
            if l[0] == "RssAnon:":
                maps[start]["rss_anon"] = int(l[1])
            if l[0] == "RssFile:":
                maps[start]["rss_file"] = int(l[1])
            if l[0] == "RssShmem:":
                maps[start]["rss_shmem"] = int(l[1])
                break

    if not ROLLUP and PSSDETAIL:  # when need comlete maps, read new metrics separatly
        rollup = PROC.readlines("%s/smaps_rollup" % pid)
        for l in rollup:
            l = l.split()
            if l[0] == "Pss_Anon:":
                maps[start]["pss_anon"] = int(l[1])
            if l[0] == "Pss_File:":
                maps[start]["pss_file"] = int(l[1])
            if l[0] == "Pss_Shmem:":
                maps[start]["pss_shmem"] = int(l[1])
                break

    if OPTIONS.mapfilter and not nomaps:
        f = {}
        for m in maps:
            if not filters(OPTIONS.mapfilter, m, lambda x: maps[x]["name"]):
                f[m] = maps[m]
        return f
    return maps


def maptotals(pids):
    totals: dict = {}
    global SWAPPSS
    for pid in pids:
        if filters(
            OPTIONS.processfilter, pid, PROC.pidcmd, PROC.pidtostr, PROC.pidname
        ) or filters(OPTIONS.userfilter, pid, PROC.pidusername):
            continue
        try:
            maps = pidmaps(pid)
            seen = {}
            for m in list(maps.keys()):
                name = maps[m]["name"]
                if name not in totals:
                    t = dict(
                        size=0,
                        rss=0,
                        pss=0,
                        shared_clean=0,
                        shared_dirty=0,
                        private_clean=0,
                        count=0,
                        private_dirty=0,
                        referenced=0,
                        swap=0,
                        pids=0,
                    )
                    if SWAPPSS:
                        t["swappss"] = 0
                else:
                    t = totals[name]
                for k in t:
                    t[k] += maps[m].get(k, 0)
                t["count"] += 1
                if name not in seen:
                    t["pids"] += 1
                    seen[name] = 1
                totals[name] = t
        except EnvironmentError:
            continue
    return totals


def pidtotals(pid):
    maps = pidmaps(pid)
    t = dict(
        size=0,
        rss=0,
        pss=0,
        shared_clean=0,
        shared_dirty=0,
        private_clean=0,
        private_dirty=0,
        referenced=0,
        swap=0,
    )
    global SWAPPSS
    global PSSDETAIL
    if SWAPPSS:
        t["swappss"] = 0
    if PSSDETAIL:
        t["pss_anon"] = 0
        t["pss_file"] = 0
        t["pss_shmem"] = 0
        t["rss_anon"] = 0
        t["rss_file"] = 0
        t["rss_shmem"] = 0

    for m in list(maps.keys()):
        for k in t:
            t[k] += maps[m].get(k, 0)

    t["uss"] = t["private_clean"] + t["private_dirty"]
    t["maps"] = len(maps)

    return t


def usertotals(pids):
    totals: dict = {}
    global PROC
    for pid in pids:
        if filters(
            OPTIONS.processfilter, pid, PROC.pidcmd, PROC.pidtostr, PROC.pidname
        ) or filters(OPTIONS.userfilter, pid, PROC.pidusername):
            continue
        try:
            maps = pidmaps(pid)
            if len(maps) == 0:
                continue
        except EnvironmentError:
            continue
        user = PROC.piduser(pid)
        if user not in totals:
            t = dict(
                size=0,
                rss=0,
                pss=0,
                shared_clean=0,
                shared_dirty=0,
                private_clean=0,
                private_dirty=0,
                count=0,
                referenced=0,
                swap=0,
            )
            if SWAPPSS:
                t["swappss"] = 0
        else:
            t = totals[user]

        for m in list(maps.keys()):
            for k in t:
                t[k] += maps[m].get(k, 0)

        t["count"] += 1
        totals[user] = t
    return totals


def cmdtotals(pids):
    totals: dict = {}
    global PROC
    for pid in pids:
        if filters(
            OPTIONS.processfilter, pid, PROC.pidcmd, PROC.pidtostr, PROC.pidname
        ) or filters(OPTIONS.userfilter, pid, PROC.pidusername):
            continue
        try:
            pt = pidtotals(pid)
            cmd = PROC.pidcmd(pid).split()[0]

            if cmd not in totals:
                t = dict(
                    size=0,
                    rss=0,
                    pss=0,
                    uss=0,
                    shared_clean=0,
                    shared_dirty=0,
                    private_clean=0,
                    private_dirty=0,
                    referenced=0,
                    swap=0,
                    pids=0,
                )
                if SWAPPSS:
                    t["swappss"] = 0
                if PSSDETAIL:
                    t["pss_anon"] = 0
                    t["pss_file"] = 0
                    t["pss_shmem"] = 0
                if RSSDETAIL:
                    t["rss_anon"] = 0
                    t["rss_file"] = 0
                    t["rss_shmem"] = 0
            else:
                t = totals[cmd]
            for k in t:
                t[k] += pt.get(k, 0)
            t["pids"] += 1
            totals[cmd] = t

        except EnvironmentError:
            continue
        except Exception:
            continue
    return totals


def sortmaps(totals, key):
    l = []
    for pid in totals:
        l.append((totals[pid][key], pid))
    l.sort()
    return [pid for pid, key in l]


def units(x):
    s = ""
    if x == 0:
        return "0"
    for s in ("", "K", "M", "G", "T"):
        if x < 1024:
            break
        x /= 1024.0
    return "%.1f%s" % (x, s)


def fromunits(x):
    s = dict(
        k=2**10,
        K=2**10,
        kB=2**10,
        KB=2**10,
        M=2**20,
        MB=2**20,
        G=2**30,
        GB=2**30,
        T=2**40,
        TB=2**40,
    )
    for k, v in list(s.items()):
        if x.endswith(k):
            return int(float(x[: -len(k)]) * v)
    sys.stderr.write("Memory size should be written with units, for example 1024M\n")
    sys.exit(-1)


def showamount(a, total):
    if OPTIONS.percent:
        if total == 0:
            return "0"
        return "%.2f%%" % (100.0 * a / total)
    elif OPTIONS.abbreviate:
        return units(a * 1024)
    return a


def filters(opt, arg, *sources):
    if not opt:
        return False
    for f in sources:
        if re.search(opt, f(arg), re.I if OPTIONS.ignorecase else 0):
            return False
    return True


def processtotals(pids):
    totals = {}
    for pid in pids:
        if filters(
            OPTIONS.processfilter, pid, PROC.pidcmd, PROC.pidtostr, PROC.pidname
        ) or filters(OPTIONS.userfilter, pid, PROC.pidusername):
            continue
        try:
            p = pidtotals(pid)
            if p["maps"] != 0:
                totals[pid] = p
        except:
            continue
    return totals


def widthstr(field, width, default):
    if width == 0:
        return "%s"
    if width < 0:
        size = default
    else:
        size = width
        IGNORE_AUTOSIZE.add(field)
    return "%-{size}.{size}s".format(size=size)


def showpids():
    p = PROC.pids()
    pt = processtotals(p)

    def showuser(p):
        if OPTIONS.numeric:
            return PROC.piduser(p)
        return PROC.pidusername(p)

    fields = dict(
        pid=("PID", lambda n: n, "% 5s", lambda x: len(pt), "process ID"),
        user=(
            "User",
            showuser,
            widthstr("user", OPTIONS.user_width, 8),
            lambda x: len(dict.fromkeys(x)),
            "owner of process",
        ),
        command=(
            "Command",
            PROC.pidcmd,
            widthstr("command", OPTIONS.cmd_width, 27),
            None,
            "process command line",
        ),
        name=(
            "Name",
            PROC.pidname,
            widthstr("comm", OPTIONS.cmd_width, 15),
            None,
            "process name",
        ),
        maps=("Maps", lambda n: pt[n]["maps"], "% 5s", sum, "total number of mappings"),
        pss=(
            "PSS",
            lambda n: pt[n]["pss"],
            "% 8a",
            sum,
            "proportional set size (including sharing)",
        ),
        uss=("USS", lambda n: pt[n]["uss"], "% 8a", sum, "unique set size"),
        swap=(
            "Swap",
            lambda n: pt[n]["swap"],
            "% 8a",
            sum,
            "amount of swap space consumed (ignoring sharing)",
        ),
        rss=(
            "RSS",
            lambda n: pt[n]["rss"],
            "% 8a",
            sum,
            "resident set size (ignoring sharing)",
        ),
        vss=(
            "VSS",
            lambda n: pt[n]["size"],
            "% 8a",
            sum,
            "virtual set size (total virtual memory mapped)",
        ),
    )

    if SWAPPSS:
        fields["tpss"] = (
            "TPSS",
            lambda n: pt[n]["pss"] + pt[n]["swappss"],
            "% 8a",
            sum,
            "Total virtual memory used (Pss + SwapPss)",
        )
        fields["swappss"] = (
            "SwapPss",
            lambda n: pt[n]["swappss"],
            "% 8a",
            sum,
            "proportional amount of swap space consumed",
        )
    if PSSDETAIL:
        fields["pssa"] = (
            "PssAnon",
            lambda n: pt[n]["pss_anon"],
            "% 8a",
            sum,
            "proportional set size of anonymous memory",
        )
        fields["pssf"] = (
            "PssFile",
            lambda n: pt[n]["pss_file"],
            "% 8a",
            sum,
            "proportional set size of mapped files",
        )
        fields["psss"] = (
            "PssShmem",
            lambda n: pt[n]["pss_shmem"],
            "% 8a",
            sum,
            "proportional set size of shared memory",
        )
    if RSSDETAIL:
        fields["rssa"] = (
            "RssAnon",
            lambda n: pt[n]["rss_anon"],
            "% 8a",
            sum,
            "proportional set size of anonymous memory",
        )
        fields["rssf"] = (
            "RssFile",
            lambda n: pt[n]["rss_file"],
            "% 8a",
            sum,
            "proportional set size of mapped files",
        )
        fields["rsss"] = (
            "RssShmem",
            lambda n: pt[n]["rss_shmem"],
            "% 8a",
            sum,
            "proportional set size of shared memory",
        )

    columns = getcolumns("pid user command swap uss pss rss", fields)

    showtable(list(pt.keys()), fields, columns.split(), OPTIONS.sort or "pss")


def showmaps():
    p = PROC.pids()
    pt = maptotals(p)

    fields = dict(
        map=(
            "Map",
            lambda n: n,
            widthstr("map", OPTIONS.mapping_width, 40),
            len,
            "mapping name",
        ),
        count=(
            "Count",
            lambda n: pt[n]["count"],
            "% 5s",
            sum,
            "number of mappings found",
        ),
        pids=(
            "PIDs",
            lambda n: pt[n]["pids"],
            "% 5s",
            sum,
            "number of PIDs using mapping",
        ),
        pss=(
            "PSS",
            lambda n: pt[n]["pss"],
            "% 8a",
            sum,
            "proportional set size (including sharing)",
        ),
        uss=(
            "USS",
            lambda n: pt[n]["private_clean"] + pt[n]["private_dirty"],
            "% 8a",
            sum,
            "unique set size",
        ),
        swap=(
            "Swap",
            lambda n: pt[n]["swap"],
            "% 8a",
            sum,
            "amount of swap space consumed (ignoring sharing)",
        ),
        rss=(
            "RSS",
            lambda n: pt[n]["rss"],
            "% 8a",
            sum,
            "resident set size (ignoring sharing)",
        ),
        vss=(
            "VSS",
            lambda n: pt[n]["size"],
            "% 8a",
            sum,
            "virtual set size (total virtual address space mapped)",
        ),
        avgpss=(
            "AVGPSS",
            lambda n: int(1.0 * pt[n]["pss"] / pt[n]["pids"]),
            "% 8a",
            sum,
            "average PSS per PID",
        ),
        avguss=(
            "AVGUSS",
            lambda n: int(
                1.0 * (pt[n]["private_clean"] + pt[n]["private_dirty"]) / pt[n]["pids"]
            ),
            "% 8a",
            sum,
            "average USS per PID",
        ),
        avgrss=(
            "AVGRSS",
            lambda n: int(1.0 * pt[n]["rss"] / pt[n]["pids"]),
            "% 8a",
            sum,
            "average RSS per PID",
        ),
        avgvss=(
            "AVGVSS",
            lambda n: int(1.0 * pt[n]["size"] / pt[n]["pids"]),
            "% 8a",
            sum,
            "average VSS per PID",
        ),
    )

    if SWAPPSS:
        fields["swappss"] = (
            "SwapPss",
            lambda n: pt[n]["swappss"],
            "% 8a",
            sum,
            "proportional amount of swap space consumed",
        )
        fields["tpss"] = (
            "TPSS",
            lambda n: pt[n]["pss"] + pt[n]["swappss"],
            "% 8a",
            sum,
            "Total virtual memory used (Pss + SwapPss)",
        )

    columns = getcolumns("map pids avgpss pss", fields)

    showtable(list(pt.keys()), fields, columns.split(), OPTIONS.sort or "pss")


def showusers():
    p = PROC.pids()
    pt = usertotals(p)

    def showuser(u):
        if OPTIONS.numeric:
            return u
        return PROC.username(u)

    fields = dict(
        user=(
            "User",
            showuser,
            widthstr("user", OPTIONS.user_width, 8),
            None,
            "user name or ID",
        ),
        count=("Count", lambda n: pt[n]["count"], "% 5s", sum, "number of processes"),
        swap=(
            "Swap",
            lambda n: pt[n]["swap"],
            "% 8a",
            sum,
            "amount of swapspace consumed (ignoring sharing)",
        ),
        pss=(
            "PSS",
            lambda n: pt[n]["pss"],
            "% 8a",
            sum,
            "proportional set size (including sharing)",
        ),
        uss=(
            "USS",
            lambda n: pt[n]["private_clean"] + pt[n]["private_dirty"],
            "% 8a",
            sum,
            "unique set size",
        ),
        rss=(
            "RSS",
            lambda n: pt[n]["rss"],
            "% 8a",
            sum,
            "resident set size (ignoring sharing)",
        ),
        vss=(
            "VSS",
            lambda n: pt[n]["size"],
            "% 8a",
            sum,
            "virtual set size (total virtual memory mapped)",
        ),
    )

    if SWAPPSS:
        fields["swappss"] = (
            "SwapPss",
            lambda n: pt[n]["swappss"],
            "% 8a",
            sum,
            "proportional amount of swap space consumed",
        )
        fields["tpss"] = (
            "TPSS",
            lambda n: pt[n]["pss"] + pt[n]["swappss"],
            "% 8a",
            sum,
            "Total virtual memory used (Pss + SwapPss)",
        )

    columns = getcolumns("user count swap uss pss rss", fields)

    showtable(list(pt.keys()), fields, columns.split(), OPTIONS.sort or "pss")


def showcmds():
    global PROC
    global SWAPPSS
    global OPTIONS
    global PSSDETAIL
    global RSSDETAIL

    p = PROC.pids()
    pt = cmdtotals(p)

    fields = dict(
        pids=("PIDs", lambda n: pt[n]["pids"], "% 5s", sum, "Number of processes"),
        command=(
            "Command",
            lambda n: n,
            widthstr("command", OPTIONS.cmd_width, 27),
            None,
            "process command",
        ),
        pss=(
            "PSS",
            lambda n: pt[n]["pss"],
            "% 8a",
            sum,
            "proportional set size (including sharing)",
        ),
        uss=("USS", lambda n: pt[n]["uss"], "% 8a", sum, "unique set size"),
        swap=(
            "Swap",
            lambda n: pt[n]["swap"],
            "% 8a",
            sum,
            "amount of swap space consumed (ignoring sharing)",
        ),
        rss=(
            "RSS",
            lambda n: pt[n]["rss"],
            "% 8a",
            sum,
            "resident set size (ignoring sharing)",
        ),
        vss=(
            "VSS",
            lambda n: pt[n]["size"],
            "% 8a",
            sum,
            "virtual set size (total virtual memory mapped)",
        ),
    )

    if SWAPPSS:
        fields["swappss"] = (
            "SwapPss",
            lambda n: pt[n]["swappss"],
            "% 8a",
            sum,
            "proportional amount of swap space consumed",
        )
        fields["tpss"] = (
            "TPSS",
            lambda n: pt[n]["pss"] + pt[n]["swappss"],
            "% 8a",
            sum,
            "Total virtual memory used (Pss + SwapPss)",
        )
    if PSSDETAIL:
        fields["pssa"] = (
            "PssAnon",
            lambda n: pt[n]["pss_anon"],
            "% 8a",
            sum,
            "proportional set size of anonymous memory (including sharing)",
        )
        fields["pssf"] = (
            "PssFile",
            lambda n: pt[n]["pss_file"],
            "% 8a",
            sum,
            "proportional set size of files (including sharing)",
        )
        fields["psss"] = (
            "PssShmem",
            lambda n: pt[n]["pss_shmem"],
            "% 8a",
            sum,
            "proportional set size of shared memory (including sharing)",
        )
    if RSSDETAIL:
        fields["rssa"] = (
            "RssAnon",
            lambda n: pt[n]["rss_anon"],
            "% 8a",
            sum,
            "proportional set size of anonymous memory (ignoring sharing)",
        )
        fields["rssf"] = (
            "RssFile",
            lambda n: pt[n]["rss_file"],
            "% 8a",
            sum,
            "proportional set size of files (including sharing)",
        )
        fields["rsss"] = (
            "RssShmem",
            lambda n: pt[n]["rss_shmem"],
            "% 8a",
            sum,
            "proportional set size of shared memory (ignoring sharing)",
        )

    columns = getcolumns("command pids swap uss pss rss", fields)

    showtable(list(pt.keys()), fields, columns.split(), OPTIONS.sort or "pss")


def mapdevzero():
    """At least by some Linux versions, memory mapped to /dev/zero is counted to Mapped instead of to AnonPages, thus Mapped can be higher than Cached"""
    global PROC
    global OPTIONS
    ps = PROC.pids()
    OPTIONS.mapfilter = "^/dev/zero$"
    pt = maptotals(ps)
    OPTIONS.mapfilter = None
    t = 0
    for r in pt:
        t += pt[r]["pss"]
    return int(t)


def mapshared():
    t = 0
    global ROLLUP
    global PSSDETAIL
    if PSSDETAIL:
        ROLLUP = True
        ps = PROC.pids()
        pt = processtotals(ps)
        for p in pt:
            t += pt[p]["pss_shmem"]
        ROLLUP = False
    return int(t)


def kernelsize():
    kernelsize = 0
    if not kernelsize and OPTIONS.kernel:
        try:
            d = os.popen("size %s" % OPTIONS.kernel).readlines()[1].split()
            if int(d[1]) == 0:  # data part missing, seems like packed file
                # try some heuristic to find gzipped part in kernel image
                packedkernel = open(OPTIONS.kernel, "rb").read()
                pos = packedkernel.find(b"\x1f\x8b")
                if pos >= 0 and pos < 25000:
                    sys.stderr.write(
                        "Parameter '%s' should be an original uncompressed compiled kernel file.\n"
                        % OPTIONS.kernel
                    )
                    sys.stderr.write(
                        "Maybe uncompressed kernel can be extracted by the command:\n"
                        "  dd if=%s bs=1 skip=%d | gzip -d >%s.unpacked\n\n"
                        % (OPTIONS.kernel, pos, OPTIONS.kernel)
                    )
            else:
                kernelsize = int(int(d[3]) / 1024 + 0.5)
        except:
            pass
    return kernelsize


def kernelmodsize():
    """Kernel modules size as part of kernel dynamic memory"""
    ms = 0.0
    try:
        md = PROC.readlines("modules")
        for m in md:
            ms += int(m.split()[1])
        ms /= 1024
    except:
        if not OPTIONS.quiet:
            sys.stderr.write("Detection of kernel modules size failed\n")
    return int(ms)


def showsystem():
    t = totalmem()
    m = MemData()
    mt = m("memtotal")
    f = m("memfree")
    kernel = kernelsize()

    # total amount mapped into userspace (ie mapped an unmapped pages) /dev/zero mappings
    u = m("anonpages") + m("mapped")

    # total amount used by hardware
    fh = int(max(t - mt - kernel, 0))

    # total amount allocated by kernel not for userspace
    kd = mt - f - u

    # total amount in kernel caches
    kdc = m("buffers") + m("sreclaimable") + m("cached") - m("mapped")

    if OPTIONS.sysdetail:
        shmp = mapshared()  # shared memory mapped by processes
        mapzero = mapdevzero()  # dev/zero mapped as files should be subtracted from files Mapped from userspace
        mapped = m("mapped") - mapzero
        modules = kernelmodsize()
        shm = m("shmem") - shmp

        global PROC
        mounts = PROC.readlines("mounts")
        ramfs = 0
        for r in mounts:
            if "ramfs" in r:
                try:
                    ramfs += int(
                        (os.popen("du -sk %s" % r.split()[1]).read()).split()[0]
                    )
                except:
                    pass
        filecache = m("cached") - mapped - shm - ramfs
        unknown = (
            mt
            - f
            - u
            - (
                modules
                + m("pagetables")
                + m("kernelstack")
                + m("slab")
                + m("buffers")
                + filecache
                + shm
                + ramfs
            )
        )
        if unknown < 0:
            unknown = 0

    lines: list[tuple]
    if OPTIONS.sysdetail:
        lines = [
            ("firmware/hardware", fh, 0, 0),
            ("kernel image", kernel, 0, 0),
            ("kernel modules", modules, 0, 0),
            ("page tables", m("pagetables"), 0, 0),
            ("kernel stack", m("kernelstack"), 0, 0),
            ("slab (all/SReclaimable)", m("slab"), m("sreclaimable"), 0),
            ("buffers", m("buffers"), m("buffers"), 0),
            ("cached (w/o mapped,tmpfs,ramfs)", filecache, filecache, 0),
            ("shared (non process tmpfs)", shm, 0, 0),
            ("ramfs", ramfs, 0, 0),
            ("unknown", unknown, 0, 0),
            ("processes (all/mapped files)", u, mapped, 0),
            ("free memory", f, f, 0),
        ]
        if "all" in OPTIONS.columns or "details" in OPTIONS.columns:
            line_all: list[tuple] = [
                ("-------------------------------", 0, 0, 0),
                ("/dev/zero mapped", 0, 0, mapzero),
                ("shared by processes", 0, 0, shmp),
                ("unevictable", 0, 0, m("unevictable")),
                ("dirty (unwritten to file)", 0, 0, m("dirty")),
                ("swapped", 0, 0, m("swaptotal") - m("swapfree")),
                ("available (estimated)", 0, 0, m("memavailable")),
            ]
            lines = lines + line_all
    else:
        lines = [
            ("firmware/hardware", fh, 0),
            ("kernel image", kernel, 0),
            ("kernel dynamic memory", kd, kdc),
            ("userspace memory", u, m("mapped")),
            ("free memory", f, f),
        ]

    fields = dict(
        order=("Order", lambda n: n, "% 2s", lambda x: "", "hierarchical order"),
        area=("Area", lambda n: lines[n][0], "%-24s", lambda x: "", "memory area"),
        used=("Used", lambda n: lines[n][1], "%10a", sum, "area in use"),
        cache=("Cache", lambda n: lines[n][2], "%10a", sum, "area used as cache"),
        noncache=(
            "Noncache",
            lambda n: lines[n][1] - lines[n][2],
            "%10a",
            sum,
            "area not reclaimable",
        ),
    )

    if OPTIONS.sysdetail:
        fields["details"] = (
            "Details",
            lambda n: lines[n][3],
            "%10a",
            sum,
            "Aditional metrics",
        )

    columns = getcolumns("area used cache noncache", fields)
    showtable(list(range(len(lines))), fields, columns.split(), OPTIONS.sort or "order")


def getcolumns(columns, fields):
    if "+" in OPTIONS.columns:
        columns = columns + " " + OPTIONS.columns.strip("+")
        return columns
    if "all" in OPTIONS.columns:
        return " ".join(fields.keys())
    return OPTIONS.columns or columns


def show_fields_error_and_exit(fields, f):
    """
    Print the known and unknown fields and exit.

    Parameters:
    - fields (dict): A dictionary containing the known fields.
    - f (str or list/set): The field(s) to check for unknownness.

    Returns:
    None
    """
    if type(f) in (list, set):
        print("unknown fields: " + " ".join(f), file=sys.stderr)
    else:
        print("unknown field %s" % f, file=sys.stderr)
    print("known fields:", file=sys.stderr)
    for l in sorted(fields):
        print("%-8s %s" % (l, fields[l][-1]), file=sys.stderr)

    sys.exit(-1)


def autosize(columns, fields, rows):
    colsizes = {}
    for c in columns:
        if c in IGNORE_AUTOSIZE:
            continue
        sizes = [1]

        if not OPTIONS.no_header:
            sizes.append(len(fields[c][0]))

        if (OPTIONS.abbreviate or OPTIONS.percent) and "a" in fields[c][2]:
            sizes.append(7)
        else:
            for r in rows:
                sizes.append(len(str(fields[c][1](r))))

        colsizes[c] = max(sizes)

    overflowcols = (set(["command", "map", "comm"]) & set(columns)) - IGNORE_AUTOSIZE
    if len(overflowcols) > 0:
        overflowcol = overflowcols.pop()
        totnoflow: int = sum(colsizes.values()) - colsizes[overflowcol]
        try:
            _, ttycolumns = [int(i) for i in os.popen("stty size", "r").read().split()]
        except:
            _, ttycolumns = (24, 80)
        maxflowcol = ttycolumns - totnoflow - len(columns)
        maxflowcol = max(maxflowcol, 10)
        colsizes[overflowcol] = min(colsizes[overflowcol], maxflowcol)

    return colsizes


def showtable(rows: list, fields: dict, columns: list, sort: str):
    header = ""
    table_format = ""
    formatter: list[Callable] = []

    if sort not in fields:
        show_fields_error_and_exit(fields, sort)

    mt = totalmem()
    memdata = MemData()
    st = memdata("swaptotal")

    missing = set(columns) - set(fields)
    if len(missing) > 0:
        show_fields_error_and_exit(fields, missing)

    if OPTIONS.autosize:
        colsizes = autosize(columns, fields, rows)
    else:
        colsizes = {}

    for n in columns:
        f = fields[n][2]
        if "a" in f:
            if n == "swap":
                formatter.append(lambda x: showamount(x, st))
            else:
                formatter.append(lambda x: showamount(x, mt))
            f = f.replace("a", "s")
        else:
            formatter.append(lambda x: x)
        if n in colsizes:
            f = re.sub(r"[0-9]+", str(colsizes[n]), f)
        table_format += f + " "
        header += f % fields[n][0] + " "

    l = []
    for n in rows:
        r = [fields[c][1](n) for c in columns]
        l.append((fields[sort][1](n), r))

    if sort in ("command", "comm"):
        l.sort(reverse=bool(OPTIONS.reverse), key=lambda v: v[0].lower())
    else:
        l.sort(reverse=bool(OPTIONS.reverse))

    if OPTIONS.format == "raw":
        if not OPTIONS.no_header:
            print(header)
            print("-" * len(header))

        if not OPTIONS.totalsonly:
            for k, r in l:
                print(table_format % tuple([f(v) for f, v in zip(formatter, r)]))

        if OPTIONS.totals:
            # totals
            t = []
            for c in columns:
                f = fields[c][3]
                if f:
                    t.append(f([fields[c][1](n) for n in rows]))
                else:
                    t.append("")

            if not OPTIONS.totalsonly:
                print("-" * len(header))
            print(table_format % tuple([f(v) for f, v in zip(formatter, t)]))
    elif OPTIONS.format == "json":
        ret: dict
        if not OPTIONS.totals:
            data = []
            for _k, row in l:
                row_data = {}
                for i, col in enumerate(columns):
                    # row_data[col] = row[i] --> raw
                    row_data[col] = formatter[i](row[i])

                data.append(row_data)
            ret = {"processes": data}
        else:
            t = []
            for c in columns:
                f = fields[c][3]
                if f:
                    t.append(f([fields[c][1](n) for n in rows]))
                else:
                    t.append("")

            row_data = {}
            for i, col in enumerate(columns):
                row_data[col] = t[i]

            ret = {"totals": row_data}

        print(json.dumps(ret))
    else:
        sys.stderr.write("Unknown format '%s'\n" % OPTIONS.format)
        sys.exit(-1)


def parse_arguments(argv=None):
    argparser = argparse.ArgumentParser(
        prog="smem2",
        description="""
                    smem2 is a tool that can give numerous reports on memory usage on Linux systems.
                    Unlike existing tools, smem2 can report proportional set size (PSS), which is a
                    more meaningful representation of the amount of memory used by libraries and
                    applications in a virtual memory system.
                    """,
        epilog=f"""
               Version: {__VERSION__} -
               for more information please visit:
               https://github.com/slhck/smem2
               """,
    )

    argparser.add_argument(
        "-H", "--no-header", action="store_true", help="Disable header line"
    )

    argparser.add_argument(
        "-c",
        "--columns",
        default="",
        type=str,
        help="Columns to show, use 'all' to show all columns",
    )

    argparser.add_argument(
        "-a",
        "--autosize",
        action="store_true",
        help="Size columns to fit terminal size",
    )

    argparser.add_argument(
        "-R", "--realmem", default=None, type=str, help="Amount of physical RAM"
    )

    argparser.add_argument(
        "-K", "--kernel", default=None, type=str, help="Path to kernel image"
    )

    argparser.add_argument(
        "-b",
        "--basename",
        action="store_true",
        help="Name of executable instead of full command",
    )
    argparser.add_argument(
        "-q", "--quiet", action="store_true", help="Suppress warnings"
    )

    argparser.add_argument("--version", action="version", version=__VERSION__)

    filter_group = argparser.add_argument_group("Filter")
    filter_group.add_argument(
        "-P", "--processfilter", default=None, type=str, help="Process filter regex"
    )

    filter_group.add_argument(
        "-M", "--mapfilter", default=None, type=str, help="Process map regex"
    )

    filter_group.add_argument(
        "-U", "--userfilter", default=None, type=str, help="Process users regex"
    )

    filter_group.add_argument(
        "--pid",
        default=None,
        type=int,
        help="Show just process memory based on one pid",
    )

    filter_group.add_argument(
        "-i", "--ignorecase", action="store_true", help="Case insensitive filter"
    )

    show_group = argparser.add_argument_group("Show")
    show_group.add_argument(
        "-m", "--mappings", action="store_true", help="Show mappings"
    )

    show_group.add_argument("-u", "--users", action="store_true", help="Show users")

    show_group.add_argument(
        "-w", "--system", action="store_true", help="Show whole system"
    )

    show_group.add_argument(
        "-W", "--sysdetail", action="store_true", help="Show whole system in detail"
    )

    show_group.add_argument(
        "-g",
        "--groupcmd",
        action="store_true",
        help="Show processes grouped by executables",
    )

    show_group.add_argument(
        "-p", "--percent", action="store_true", help="Show percentage"
    )

    show_group.add_argument(
        "-k", "--abbreviate", action="store_true", help="Show unit suffixes"
    )

    show_group.add_argument("-t", "--totals", action="store_true", help="Show totals")
    show_group.add_argument(
        "-T", "--totalsonly", action="store_true", help="Show totals only"
    )

    show_group.add_argument(
        "-F",
        "--format",
        default="raw",
        type=str,
        help="Output format (raw, json)",
    )

    sort_group = argparser.add_argument_group("Sort")
    sort_group.add_argument("-n", "--numeric", action="store_true", help="Numeric sort")

    sort_group.add_argument(
        "-s", "--sort", default=None, type=str, help="Field to sort on"
    )

    sort_group.add_argument("-r", "--reverse", action="store_true", help="Reverse sort")

    width_group = argparser.add_argument_group("Width")
    width_group.add_argument(
        "--cmd-width",
        default=-1,
        type=int,
        help="Text width for commands (0=as needed)",
    )

    width_group.add_argument(
        "--name-width",
        default=-1,
        type=int,
        help="Text width for command names (0=as needed)",
    )

    width_group.add_argument(
        "--user-width",
        default=-1,
        type=int,
        help="Text width for user names (0=as needed)",
    )

    width_group.add_argument(
        "--mapping-width",
        default=-1,
        type=int,
        help="Text width for mapping names (0=as needed)",
    )

    #    argparser.add_argument('-S', '--source',
    #            default=None,
    #            type=str,
    #            help="/proc data source")

    return argparser.parse_args()


def setdatasources():
    # constants
    global RSSDETAIL
    global PSSDETAIL
    global ROLLUP
    global PROC
    global OWNPID
    global SWAPPSS

    OWNPID = os.getpid()

    """ New kernel features detection """
    RSSDETAIL = False
    PSSDETAIL = True
    ROLLUP = True
    rd = PROC.readlines("%s/status" % OWNPID)
    for r in rd:
        if "RssAnon:" in r:
            RSSDETAIL = True
            break

    map = pidmaps(OWNPID, nomaps=True)
    map = map[list(map.keys())[0]]

    if "pss" not in map and not OPTIONS.quiet:
        sys.stderr.write("Warning: Kernel does not appear to support PSS measurement\n")

    if "swappss" in map:
        SWAPPSS = True
    else:
        SWAPPSS = False
        if not OPTIONS.quiet:
            sys.stderr.write(
                "Warning: Kernel does not appear to support SwapPSS measurement\n"
            )

    if "pss_anon" in map:
        PSSDETAIL = True
    else:
        PSSDETAIL = False
        if not OPTIONS.quiet:
            sys.stderr.write(
                "Warning: Kernel does not appear to support Pss Anon/File/Shmem measurement\n"
            )

    """ some smem2 features need full smaps"""
    if (
        OPTIONS.mapfilter
        or OPTIONS.mappings
        or "maps" in OPTIONS.columns
        or ("all" in OPTIONS.columns and not OPTIONS.groupcmd)
    ):
        ROLLUP = False


def main():
    """Main function for smem2"""
    global OPTIONS
    global PROC

    OPTIONS = parse_arguments(sys.argv)
    if OPTIONS.totalsonly:
        OPTIONS.totals = True

    if not os.getuid() == 0 and not OPTIONS.quiet:
        sys.stderr.write(
            "Warning: Some results might be incomplete when smem2 doesn't run with root privileges\n"
        )

    PROC = ProcessData()

    setdatasources()
    try:
        if OPTIONS.mappings:
            showmaps()
        elif OPTIONS.users:
            showusers()
        elif OPTIONS.system or OPTIONS.sysdetail:
            showsystem()
        elif OPTIONS.groupcmd:
            showcmds()
        else:
            showpids()
    except IOError as e:
        if e.errno == errno.EPIPE:
            pass
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":
    main()
